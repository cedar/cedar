SIMPLE USE CASES:
=================
(see a complete example at the end of the file)

I want to write data over the network:
--------------------------------------

#include <cedar/auxiliaries/net/NetWriter.h>

  cv::Mat mat= ...; // we will send this matrix over the network
  NetWriter<cv::Mat> writer("mychannel"); // this is our reader class

  // ...

  writer.write(mat);


I want to read the same data from the network:
----------------------------------------------

#include <cedar/auxiliaries/net/NetBlockingReader.h>
  
  cv::Mat mat;
  NetBlockingReader<cv::Mat> reader("mychannel");

  mat= reader.read();

  // Please make sure that your Writer and Reader use the same
  // 'channel'!


FAQ:
====

Question: What datatypes are supported?
---------------------------------------

As you can see the NetReaders and NetWriters are template classes. They
can only be used with variable types for which support has been programmed
in. These are at the moment:

  - int, char, short, long (all also unsigned), float, double, bool
  - cv::Mat
  - cv::Mat_<float> 
  - ... more to be added at your request ...


Question: How does the transport work?
--------------------------------------

The NetWriter/Readers use the YARP library internally, but are designed
to transparently wrap around YARP, so you don't need to worry about YARP.
Note, that if you don't have a 'yarp server' started yourself the 
NetWriter/Reader classes will start a yarp server themselves (allthough
this may cause some delay in your code).

At the moment, we use TCP/IP as network protocoll. Even locally.


Question: The 'channel's I define are not the ones I see YARP using
-------------------------------------------------------------------
You have to pass a 'channel'-name-string to the constructors of the
NetWriter/Reader. These are also called 'ports's in YARP nomenclature.

The NetWriter/Reader classes internally rename your 'channels', adding
prefixes and suffixes to administer the different dispersed readers that
listen to a YARP port.

YARP does internally resolve port naming conflicts. (js: TODO!)


Question: What different types of readers are there:
----------------------------------------------------
The NetBlockingReader ... class blocks the execution of your code until
                      input arrives over its channel, while the ...
    NetReader         ... class (NetReader.h) does not block, 
                      but will throw an
                      NetUnexpectedDataException when there is no
                      data available. See below.


Question: What about exceptions:
--------------------------------
The readers may throw the following exceptions which you may want to
catch and react to in your code:

#include <cedar/auxiliaries/net/exceptions/NetException.h>

  NetUnexpectedDataException: Will be thrown when there was no data
      on the channel (and if the reader is not a blocking one)
      OR some transmission error occurred. It signals you that the
      return value of read() is unuseable.
      You will want to catch this to write robust code.

  NetWaitingForWriterException: Will be thrown if you read the
      reader class before the (remote) writer class was instantiated
      (instantiation connects the ports).
      You will want to catch this to implement a polling behaviour to 
      wait for the writer channel.

Both reader and writer will throw:

  NetMissingForRessourceException: Which will typically be thrown if 
      YARP could not be initialized properly.

A COMPLETE EXAMPLE:
===================

#include <cedar/auxiliaries/net/NetWriter.h>
#include <cedar/auxiliaries/net/NetBlockingReader.h>

  // ...

  // instantiate reader class
  try 
  {
    NetBlockingReader<cv::Mat> reader("mychannel");
      // note: this is a blocking reader
  }
  catch (NetMissingRessourceException &E)
  {
    // somehow YARP doesnt work ... :( typically fatal.
    exit(1);
  }

  // ...

  // read the data over the network
  while (1)
  {
    try
    {
      mat= reader.read(); // note: we use a blocking reader
    }
    catch (NetWaitingForWriterException &E) 
    {
      // wait for remote writer to be initialized ...
      sleep(2); // 2 seconds
      continue;
    }
    catch (NetUnexpectedDataException &E)
    {
      // invalid or corrupted data, ignore
      continue;
    }
    catch (NetMissingRessourceException &E)
    {
      // somehow YARP doesnt work ... :( typically fatal.
      exit(1);
    }

    break; // mat holds the result
  }



