/*!

@page ProcessingTutorials Tutorials for the Processing Framework

@todo Most of the code on this page hasn't yet been tested directly; we need to make an examples folder and put it there.

This page offers several tutorials for using cedar's processing framework. A detailed description of the framework can
be found at @ref ProcessingIntroduction. 

This page contains the following sections:

<ol>
  <li>@ref ProcessingTutorialFirstStep</li>
  <li>@ref ProcessingTutorialDeclarations</li>
  <li>@ref ProcessingTutorialFirstStepArchitectureFile</li>
  <li>@ref ProcessingTutorialPlugin</li>
  <li>@ref ProcessingTutorialUsingTheProcessingIde</li>
  <li>@ref ProcessingTutorialFirstStepDynamics</li>
  <li>@ref ProcessingTutorialDataValidation</li>
  <li>@ref ProcessingTutorialInputCollections</li>
  <li>@ref ProcessingTutorialOwnParameters</li>
  <li>@ref ProcessingTutorialSummary</li>
</ol>

Tutorials are ordered into separate categories: beginner's tutorials are recommended for people who use the processing
framework for the first time. They introduce all the features necessary to work with the processing framework.
Intermediate tutorials introduce features that are optional but provide a more effective way of using the framework,
such as input validation and others. Advanced tutorials cover features that are likely to only be needed in very few
situations and require more advanced programming. Thus, the level of a tutorial doesn't reflect its difficulty, but
rather it is a hint at what level of knowledge about the framework is expected from the reader.
  

@section ProcessingTutorialFirstStep Beginner's Tutorial: One Small Step

In this section, we will give a brief introduction on how to create a new processing step that adheres to the principles
of the processing framework.

@subsection ProcessingTutorialFirstStep_Planning Planning

The first thing to do when developing a new processing step (cedar::proc::Step) is to think about what the new step is
supposed to do. For now, we pick a fairly simple example: we will create a processing step that receives two matrices
and adds them together.

@subsection ProcessingTutorialFirstStep_NewClass A New Class

First, let's decide to call our class SimpleSumation. In order for it to work within the framework, it has to inherit
cedar::proc::Step, so the class header looks something like this

@code
// ...
class SimpleSummation : public cedar::proc::Step
{
  // we assume that you declare all members and functions used throughout the tutorial here
};
// ...
@endcode

Let's begin by implementing the constructor. From our planning stage, we already know what the inputs and outputs of the
step are going to be: we need two inputs (the matrices we plan to add up) and one output (the sum). In terms of the
processing framework, this is expressed in the constructor:

@code
SimpleSummation::SimpleSummation()
:
// mOutput is a member, its type is cedar::aux::MatDataPtr 
mOutput(new cedar::aux::MatData(cv::Mat::zeros(1, 1, CV_32F)))
{
  /* Declare both inputs; the "true" means that the inputs are mandatory, i.e., the step will not run unless both of the
     inputs are connected to data. 
   */
  this->declareInput("operand1", true);
  this->declareInput("operand2", true);
  
  // Declare the output and set it to the output matrix defined above.
  this->declareOutput("sum", mOutput);
}
@endcode

That's all we need to do in the constructor for now. In order to be able to use the step, we also have to tell it what
to compute; for this, we implement the compute function:

@code
// The arguments are unused here
void SimpleSummation::compute(const cedar::proc::Arguments&)
{
  // Using data like this is more convenient.
  cv::Mat& sum = mOutput->getData();

  // Get a pointer to the first input.
  cedar::aux::DataPtr op1 = this->getInputSlot("operand1")->getData();
  // Retreive its stored data and add it to the sum. Note, that we assume that op1 can be cast to MatData!
  sum = op1->getData<cedar::aux::MatData>();

  // Same as above for the second input.
  cedar::aux::DataPtr op2 = this->getInputSlot("operand2")->getData();
  sum += op2->getData<cedar::aux::MatData>();
  
  // In a console application, this let us see that the computation is actually happening.
  std::cout << "A sum was computed!" << std::endl;
}
@endcode

Note, that the compute function does not check that operand1 and operand2 are valid, non-null pointers. This is done
automatically by the framework, because we specified the inputs to be mandatory in the constructor. Something that we do
assume here is that the data connected to the input slots can be cast to cedar::aux::MatData. This assumption can be
checked automatically by the framework, as is described in @ref ProcessingTutorialDataValidation.




@subsection ProcessingTutorialRunningTheSimpleStep Creating an Architecture

Now that we have our simple summation step, we want to actually let it do something. For this purpose, we need two
sources for inputs that we can sum together. Luckily, cedar comes with a few predefined input sources, and for the
tutorial we chose a cedar::proc::sources::GaussInput. Generally, inputs to steps are of course not restricted to the
Gauss inputs, but can be the output of any other processing step. This also means that if cedar doesn't provide the kind
of input you need, you can just write one yourself.

We now write a main method that connects up our architecture:
@code
#include <cedar/processing/Network.h>
#include <cedar/processing/sources/GaussInput.h>
#include "SimpleSummation.h" // header for the class we have written above

int main(int argc, char**) // we don't use the arguments here
{
@endcode

The first thing we need in order to connect some steps is a network:
@code
  cedar::proc::NetworkPtr network(new cedar::proc::Network());
@endcode
We can now start adding steps to this network:
@code
  boost::shared_ptr<SimpleSummation> sum(new SimpleSummation());
  // This adds the sum step to the network under the name "sum".
  network->add(sum, "sum");
  
  // Gauss inputs
  cedar::proc::sources::GaussInputPtr gauss1(new cedar::proc::sources::GaussInput());
  network->add(gauss1, "gauss1");
  cedar::proc::sources::GaussInputPtr gauss2(new cedar::proc::sources::GaussInput());
  network->add(gauss2, "gauss2");
@endcode
Note that the names we gave the steps are unique identifiers in the network. If you later chose to save the network to a
file, you can use these names to retrieve the pointers to the steps from the network with the
cedar::proc::Network::getElement function.

Now it is time to connect things up:
@code
  // connect the first gauss to the sum
  network->connectSlots("gauss1.Gauss input", "sum.operand1");
  // connect the second gauss to the sum
  network->connectSlots("gauss1.Gauss input", "sum.operand2");
  
  return 0;
}
@endcode
And that's it, if you compile and run this program your step should now be computed.

@todo compute wouldn't actually be called here, even though it should.

By the way, if you dislike writing this main method, you can use plugins and architecture files instead (see the next
two sections, @ref ProcessingTutorialDeclarations and @ref ProcessingTutorialFirstStepArchitectureFile) or just use the
processingIde to do it all in a user interface (see @ref ProcessingTutorialUsingTheProcessingIde).


@section ProcessingTutorialDeclarations Beginner's Tutorial: ElementDeclarations

In the previous tutorials we have demonstrated how to write a simple processing step. So far, it may not have been clear
what the actual advantage of writing all the code described above for a simple matrix addition is. However, in this
section, we will start to use the actual emergent power of this added code. Note that we won't have to modify the 
SimpleSummation code we have written above for this!

We start out by turning the SimpleSummation step into a class that is actually known by the framework. One way of doing
this is by simply adding a declaration for the step in the main method of our program:
@code
#include <cedar/processing/ElementDeclaration.h>
#include <cedar/processing/DeclarationRegistry.h>
// other includes you might need

int main(int argc, char**) // we still don't use the arguments
{
  // Create the class's declaration
  cedar::proc::ElementDeclarationPtr sum_declaration
  (
    new cedar::proc::ElementDeclarationTemplate<yourNamespace::SimpleSummation> 
    (
      "The Category you Would Like the Step to Have, Used Mainly by the UI"
    )
  );
  cedar::proc::DeclarationRegistrySingleton::getInstance()->declareClass(sum_declaration);
@endcode
Note, that we assumed here that the SimpleSummation class lives in some namespace @em yourNamespace. Using the
cedar::proc::ElementDeclaration shown above, the framework will be able to create new objects of the class
SimpleSummation based on its class id which is autogenerated to be @em yourNamespace.SimpleSummation. This is useful
later, e.g., when reading an architecture from a file, but for now we can also use it ro replace the lines
@code
  cedar::proc::NetworkPtr network(new cedar::proc::Network());
  
  boost::shared_ptr<SimpleSummation> sum(new SimpleSummation());
  // This adds the sum step to the network under the name "sum".
  network->add(sum, "sum");
  
  // Gauss inputs
  cedar::proc::sources::GaussInputPtr gauss1(new cedar::proc::sources::GaussInput());
  network->add(gauss1, "gauss1");
  cedar::proc::sources::GaussInputPtr gauss2(new cedar::proc::sources::GaussInput());
  network->add(gauss2, "gauss2");
@endcode
from the example in @ref ProcessingTutorialRunningTheSimpleStep by
@code
  cedar::proc::NetworkPtr network(new cedar::proc::Network());
  
  network->add("yourNamespace.SimpleSummation", "sum");
  network->add("cedar.processing.sources.GaussInput", "gauss1");
  network->add("cedar.processing.sources.GaussInput", "gauss2");
@endcode
Note that we don't need to declare the Gauss input here, as it is automatically declared as a standard within the
framework.

The connect calls used for wiring things up stay the same and complete our main method:
@code
  network->connectSlots("gauss1.Gauss input", "sum.operand1");
  network->connectSlots("gauss1.Gauss input", "sum.operand2");
  
  return 0;
}
@endcode

"But dear tutorial-writer-person, when all this is done with strings, can't I just write a text file or something to do
 most of this stuff" you ask? Why yes, or something indeed! Read on in @ref ProcessingTutorialFirstStepArchitectureFile.


@section ProcessingTutorialFirstStepArchitectureFile Beginner's Tutorial: Architecture Files

Architecture files are a specific file format used by the processing framework to describe the structure of a processing
architecture, such as the two Gauss inputs and the summation step as well as their connections described in the previous
tutorials.

In order to wire up a network with these connections, we first write the architecture file. Architecture files are
written in json format, and -- in our case -- look like this:
@code
{
  "meta":
  {
    "format": "1"
  },
  "steps":
  {
    "yourNamespace.SimpleSummation":
    {
      "name": "sum"
    },
    "cedar.processing.sources.GaussInput":
    {
      "name": "gauss1"
    },
    "cedar.processing.sources.GaussInput":
    {
      "name": "gauss2"
    }
  },
  "connections":
  [
    {
      "source": "gauss1.Gauss input",
      "target": "sum.operand1"
    },
    {
      "source": "gauss2.Gauss input",
      "target": "sum.operand2"
    }
  ]
}
@endcode
Hopefully, most of this file is self-explanatory. The format entry in the meta node specifies what format version for
architecture files we are using; it can be ommitted, however, it is recommended that it is specified so that newer
versions of the framework may still read (or at least convert) these files properly. The steps node contains subnodes
describing what kind of processing steps we have in our architecture, and for each step, what its parameters are (in the
example, name is the only parameter). The connections node is a list of connections, where each connection specifies the
source, i.e., an output of a step, and a target, i.e., an input of a different step.

Onwards, now, to the loading of this architecture. We have to declare our class again and create a network
like we did before:
@code
int main(int, char**)
{
  // Create the class's declaration
  cedar::proc::ElementDeclarationPtr sum_declaration
  (
    new cedar::proc::ElementDeclarationTemplate<yourNamespace::SimpleSummation> 
    (
      "The Category you Would Like the Step to Have, Used Mainly by the UI"
    )
  );
  cedar::proc::DeclarationRegistrySingleton::getInstance()->declareClass(sum_declaration);
  
  cedar::proc::NetworkPtr network(new cedar::proc::Network());
@endcode

Now, instead of declaring our network in the code, we can just read the file:
@code
  network->readFile("path/to/the/file");
  
  return 0;
}
@endcode
And that's it!

"But dear tutorial-writer-person, do I really have to write these configuration files by hand? I'm much more of a
 click-and-play person!" you say? Why yes, click-and-play indeed! Read on how to make the summation step available to
 the UI in @ref ProcessingTutorialPlugin, and on how to use the UI in ProcessingTutorialUsingTheProcessingIde.

@remarks In future versions, we plan to provide a ready-made console application for this purpose so you won't even have
         to write this code.


@section ProcessingTutorialPlugin Beginner's Tutorial: Plug In and Play

As a prepraration for using the processinIde, we first have to group our declarations into a plugin. These plugins can
then be loaded from the processingIde and used for creating architecture files in a comfortable way.

The first step towards this is to move the SimpleSummation step into a separate project that is compiled as a library
(i.e., .so, .dylib or .dll, depending on your operating system). Let us assume that our library compiles to
@em libSimpleSummation.so and, so far, contains the code from the previous tutorials in @em SimpleSummation.h and
@em SimpleSummation.cpp. In order to turn this library into a plugin, we add two more files: @em plugin.h and
@em plugin.cpp. The header file must always contain at least this:
@code
#ifndef SIMPLE_SUMMATION_PLUGIN_H
#define SIMPLE_SUMMATION_PLUGIN_H

#include <cedar/processing/PluginDeclaration.h>

CEDAR_BEGIN_PLUGIN_DECLARATION

#ifdef MSVC
__declspec(dllexport)
#endif
void pluginDeclaration(cedar::proc::PluginDeclarationPtr plugin);

CEDAR_END_PLUGIN_DECLARATION

#endif // SIMPLE_SUMMATION_PLUGIN_H
@endcode

Upon loading the plugin, the processing framework calls the function declared here and imports everything declared in
the cedar::proc::PluginDeclaration. Therefore, we declare our summation step in this function:
@code
#include "Plugin.h"
#include "SimpleSummation.h"

#include <cedar/processing/ElementDeclaration.h>

void pluginDeclaration(cedar::proc::PluginDeclarationPtr plugin)
{
  cedar::proc::ElementDeclarationPtr summation_decl
  (
    new cedar::proc::ElementDeclarationTemplate
    <
    utilities::SimpleSummation
    >
    (
      "Utilities"
    )
  );
  plugin->add(summation_decl);
}
@endcode
The declaration code should look familiar from @ref ProcessingTutorialFirstStepArchitectureFile. After recompiling, now,
the plugin is ready for use!


@section ProcessingTutorialUsingTheProcessingIde Beginner's Tutorial: Using the processingIde

In the folder \em cedar/bin, you can find an application called processingIde. If you run it, you can generate the
configuration files described in @ref ProcessingTutorialFirstStepArchitectureFile using a visual representation.

@todo Screenshots and explanations.

@section ProcessingTutorialFirstStepDynamics Beginner's Tutorial: Dynamics


@section ProcessingTutorialDataValidation Intermediate Tutorial: Data Validation


@section ProcessingTutorialInputCollections Intermediate Tutorial: Input Collections

\"Dear tutorial-writer-person, way back in @ref ProcessingTutorialFirstStep_NewClass we wrote a summation class that only
 has two inputs. Doesn't this get annoying if one wants to sum up a lot of matrices?\"
Why yes, it does. Therefore, we have a special solution for this sort of problem: input collections. Instead of having
an input that can only be associated with a single data object, these collections can receive an indetermined number of
data. Defining an input as a collection can be done by declaring it in a step's constructor like this:
@code
  this->declareInputCollection("operands");
@endcode
Note that input collections are never mandatory. In the compute function, we can now sum all of the inputs like this:
@code
void SimpleSummation::compute(const cedar::proc::Arguments&)
{
  cedar::proc::ExternalDataPtr input_slot = this->getInputSlot("input");
  
  if (input_slot->getDataCount() <= 0)
  {
    return;
  }
    
  cv::Mat& sum = mOutput->getData();
  sum = input_slot->getData(0);
  
  for (size_t i = 0; i < input_slot->getDataCount(); ++i)
  {
    cedar::aux::DataPtr data = input_slot->getData(i);
    if (data)
    {
      sum += data->getData<cv::Mat>();
    }
  }
}
@endcode

@section ProcessingTutorialOwnParameters Advanced Tutorial: Writing your own Parameter Type

When the standard parameter types that cedar provides just don't suffice for expressing settings of your class, you have
the option of implementing your own parameter type. 


@section ProcessingTutorialSummary Summary

"But dear tutorial-writer-person, is this really everything?" you ask? No, it is not. By nature, a tutorial can only
introduce so many features. If you have read all of the advanced tutorials, you should know a great deal about the
processing framework, but there is probably still more to learn, e.g., by reading the documentation on the classes in
cedar::proc and getting to grips with all the details in @ref ProcessingIntroduction. In addition, we still have a giant
pile of features that we want to implement (and that we wish we already had), so keep your eyes open for new releases!

*/