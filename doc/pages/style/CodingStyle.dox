/*!

@page CodingStyle Coding Style

@section CodingStyleIntroduction Introduction
cedar sticks to a strict coding style, which is based on the UWYN 
<a href=http://www.uwyn.com/resources/uwyn_cpp_coding_standard>coding standard</a>. The style presented on this page 
overrides some of the content of the UWYN coding standard. If there is no rule on this page that applies for a specific
code piece, the fallback is always the UWYN coding standard. If neither of the sources contain rules which apply, the
code piece is most probably in alignment with cedar's style.

@section CodingStyleNames Names and prefixes
- class names start with a capital letter and have a singular form (e.g. Example)
- method names start in lower case (with a verb), but every new word starts with a capital letter
(e.g. \b getMyMember() )
- member variables and method parameters usually start with one of the following prefixes and continue with capital
letters for new words (e.g. \b mpMyMemberPointer )
- prefixes (in this order):
  - leading underscore for parameters loaded from a configuration file
  - small m for member variables
  - small p for pointer variables
  - small e for external pointer variables
  - e.g. \b mpeMyExternalMemberPointerFromAConfigurationFile
- local variables are all lower case, words and prefixes are separated with an underscore (e.g. \b p_local_pointer )
- constants are all upper case, with additional prefix (e.g. \b M_MY_MEMBER_CONSTANT )
- pointer style:
  - if you declare a pointer, put the * adjacent to the pointer name (e.g. Example *mpMyExamplePointer; )
  - put the * adjacent to the pointer type otherwise (e.g. Example* getExample())

@section CodingStyleBraces Braces and Parentheses
- place braces under and inline with keywords
- always use braces, even for single line statements
- leave one space between keywords and parentheses (e.g. if (condition) )
- put parentheses directly after method names (e.g. myMethod(parameter) )

@section CodingStyleClassDesign Class Design
- always initialize members
- make sure that each destructor cleans all allocated objects and memory
- keep your interface clean - only declare methods as public, if a user needs them

 */