#=======================================================================================================================
#
#   Copyright 2011 Institut fuer Neuroinformatik, Ruhr-Universitaet Bochum, Germany
# 
#   This file is part of cedar.
#
#   cedar is free software: you can redistribute it and/or modify it under
#   the terms of the GNU Lesser General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   cedar is distributed in the hope that it will be useful, but WITHOUT ANY
#   WARRANTY; without even the implied warranty of MERCHANTABILITY or
#   FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
#   License for more details.
#
#   You should have received a copy of the GNU Lesser General Public License
#   along with cedar. If not, see <http://www.gnu.org/licenses/>.
#
#=======================================================================================================================
#
#   Institute:   Ruhr-Universitaet Bochum
#                Institut fuer Neuroinformatik
#
#   File:        macros.txt
#
#   Maintainer:  Mathis Richter
#   Email:       mathis.richter@ini.rub.de
#   Date:        2010 11 29
#
#   Description: CMake macros for cedar.
#
#   Credits:
#
#=======================================================================================================================

#######################################################################################################################
# CMake macros for cedar
########################################################################################################################


########################################################################################################################

macro(cedar_add_unit_test)
  parse_arguments(unitTest "ARGUMENTS" "" ${ARGN})
  car(unitTestName ${unitTest_DEFAULT_ARGS})
  cdr(unitTestSources ${unitTest_DEFAULT_ARGS})

  cedar_add_test(${unitTestName} ${unitTestSources} PREFIX "unitTest" DIRECTORY ${CEDAR_UNIT_TEST_DIR} ARGUMENTS unitTest_ARGUMENTS AUTOMATIC)
endmacro(cedar_add_unit_test)

macro(cedar_add_interactive_test)
  parse_arguments(interactiveTest "ARGUMENTS" "" ${ARGN})
  car(interactiveTestName ${interactiveTest_DEFAULT_ARGS})
  cdr(interactiveTestSources ${interactiveTest_DEFAULT_ARGS})

  cedar_add_test(${interactiveTestName} ${interactiveTestSources} PREFIX "interactiveTest" DIRECTORY ${CEDAR_INTERACTIVE_TEST_DIR} ARGUMENTS interactiveTest_ARGUMENTS)
endmacro(cedar_add_interactive_test)

macro(cedar_add_test)
  parse_arguments(test "PREFIX;DIRECTORY;ARGUMENTS" "AUTOMATIC" ${ARGN})
  car(testName ${test_DEFAULT_ARGS})
  cdr(testSources ${test_DEFAULT_ARGS})

  # remove the absolute part from the current source path and save the result in 'testSubdirectory'
  string(REPLACE "${test_DIRECTORY}/" "" testSubdirectory "${CMAKE_CURRENT_SOURCE_DIR}")
  # extract the folder name from the current source path and remove it from 'testSubdirectory'
  string(REGEX REPLACE ".*/(.+)$" "\\1" testFolderName "${CMAKE_CURRENT_SOURCE_DIR}")
  string(REPLACE "/${testFolderName}" "" testSubdirectory "${testSubdirectory}")

  # temporarily change the directory where executables are created, so that we can have appropriate subdirectories
  set(originalRuntimeOutputDirectory ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CEDAR_EXE_DIR}/${testSubdirectory})

  # compose the name of the executable from a given prefix and the test name
  set(testExecutableName "${test_PREFIX}_${testName}")
  
  # add the executable with the given name, specifying all source files needed for compilation
  #
  # add_executable(<executable name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)
  add_executable(${testExecutableName} ${testSources})
  
  # add the unit test to the CMake build system (will create a build target and run the test when calling 'make test')
  # This sets up the unit test so that it is run as if the executable were lying in the source path of the unit test,
  # so that you can put test configuration files into the source directory.
  #
  # add_test(<test identifier> <executable name> <arguments for the test>)
  if (test_AUTOMATIC)
    add_test(${testName} ${CMAKE_COMMAND} -E chdir ${test_DIRECTORY}/${testSubdirectory}/${testName} ${CEDAR_EXE_DIR}/${testSubdirectory}/${testExecutableName} ${test_ARGUMENTS})
  endif (test_AUTOMATIC)
  
  # link all cedar and third party libraries into the unit test executable
  target_link_libraries(${testExecutableName} ${CEDAR_LIBS} ${CEDAR_THIRD_PARTY_LIBS})
  
  # change the runtime output directory back to the original value
  set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${originalRuntimeOutputDirectory})
endmacro(cedar_add_test)

########################################################################################################################

macro(cedar_add_demo arguments)
  # extract the folder name from the current source path and use it as a name for the demo
  string(REGEX REPLACE ".*/(.+)$" "\\1" demoName "${CMAKE_CURRENT_SOURCE_DIR}")

  # find all cpp source files in the current source folder and save them in a list
  file(GLOB sourceFiles ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)

  # remove the ${CEDAR_DEMO_DIR} from the current source path and save the result in 'demoSubdirectory'
  string(REPLACE "${CEDAR_DEMO_DIR}/" "" demoSubdirectory "${CMAKE_CURRENT_SOURCE_DIR}")
  # remove the folder name from 'demoSubdirectory'
  string(REPLACE "/${demoName}" "" demoSubdirectory "${demoSubdirectory}")

  # temporarily change the directory where executables are created, so that we can have appropriate subdirectories
  set(originalRuntimeOutputDirectory ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CEDAR_EXE_DIR}/${demoSubdirectory})

  # compose the name of the executable from a 'demo_' prefix and the demo name
  set(demoExecutableName demo_${demoName})
  
  # add the executable with the given name, specifying all source files needed for compilation
  #
  # add_executable(<executable name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)
  add_executable(${demoExecutableName} ${sourceFiles})

  # extract the name of the library from the demo source path
#  string(REGEX REPLACE "([^/]+)(/[^/]*)*$" "\\1" libraryName "${demoSubdirectory}")
  
  # link all cedar and third party libraries into the demo executable
  target_link_libraries(${demoExecutableName} ${CEDAR_LIBS} ${CEDAR_THIRD_PARTY_LIBS})
  
  # change the runtime output directory back to the original value
  set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${originalRuntimeOutputDirectory})
endmacro(cedar_add_demo)


########################################################################################################################

macro(cedar_get_subdirectories path)
  file(GLOB returnedSubdirectories ${path}/*/)
  list(LENGTH returnedSubdirectories localNumberOfSubdirectories)

  if (localNumberOfSubdirectories GREATER 0)
    list(REMOVE_ITEM returnedSubdirectories "${path}/.svn")
    foreach (subdirectory ${returnedSubdirectories})
      if (NOT IS_DIRECTORY ${subdirectory})
        list(REMOVE_ITEM returnedSubdirectories "${subdirectory}")
      endif(NOT IS_DIRECTORY ${subdirectory})
    endforeach(subdirectory)
  endif (localNumberOfSubdirectories GREATER 0)
endmacro(cedar_get_subdirectories)

########################################################################################################################

# This macro adds a new library to cedar.
# Syntax:
# cedar_add_library(
#                     library_name source1 source2 ...
#                     [HEADERS header1 header2 ...]
#                     [MOC_HEADERS header1 header2 ...]
#                     [LINK_LIBRARIES lib1 lib2 ...]
#                   )
# library_name   name of the new library
# source1 ...    *.cpp and *.h files that have to be compiled into the library
# HEADERS        header files (will be installed when calling 'make install')
# MOC_HEADERS    header files that generate (Qt) moc-files
# LINK_LIBRARIES libraries that need to link to from the new library (important for MacOS linking process)
#
# see http://www.cmake.org/Wiki/CMakeMacroParseArguments for a description of the parsing
macro(cedar_add_library)
  parse_arguments(library "HEADERS;MOC_HEADERS;LINK_LIBRARIES" "" ${ARGN})
  car(libraryName ${library_DEFAULT_ARGS})
  cdr(librarySources ${library_DEFAULT_ARGS})

  # extract the path to the header files, relative to the cedar source directory
  string(REGEX REPLACE "${CEDAR_SOURCE_DIR}" "" relativePathToHeaders "${CMAKE_CURRENT_SOURCE_DIR}")

  foreach(headerFile ${library_HEADERS})
    # extract the relative path information that is stored in the 'name' of the header file
    # (they are potentially listed like 'math/sigmoids.h')
    string(REGEX REPLACE "((.*/)*).+$" "\\1" relativePathInfo "${headerFile}")
    # add the header file to the 'make install' target
    install(FILES ${headerFile} DESTINATION ${CEDAR_HEADER_INSTALL_DIR}/${relativePathToHeaders}/${relativePathInfo})
  endforeach(headerFile)

  # create moc files from those headers that contain the Q_OBJECT macro
  qt4_wrap_cpp(mocHeaders ${library_MOC_HEADERS})
  set(librarySources ${librarySources} ${mocHeaders})

  # add the library and link it to all relevant cedar and third party libraries
  set(CEDAR_LIBS ${CEDAR_LIBS} ${libraryName} CACHE INTERNAL "")
  add_library(${libraryName} ${CEDAR_LIB_TYPE} ${librarySources})
  target_link_libraries(${libraryName} ${CEDAR_THIRD_PARTY_LIBS} ${library_LINK_LIBRARIES})

  # add the library to the 'make install' target
  install(TARGETS ${libraryName} LIBRARY DESTINATION ${CEDAR_LIB_INSTALL_DIR})
endmacro(cedar_add_library)

########################################################################################################################

MACRO(CAR var)
  SET(${var} ${ARGV1})
ENDMACRO(CAR)

########################################################################################################################

MACRO(CDR var junk)
  SET(${var} ${ARGN})
ENDMACRO(CDR)

########################################################################################################################

MACRO(PARSE_ARGUMENTS prefix arg_names option_names)
  SET(DEFAULT_ARGS)
  FOREACH(arg_name ${arg_names})    
    SET(${prefix}_${arg_name})
  ENDFOREACH(arg_name)
  FOREACH(option ${option_names})
    SET(${prefix}_${option} FALSE)
  ENDFOREACH(option)

  SET(current_arg_name DEFAULT_ARGS)
  SET(current_arg_list)
  FOREACH(arg ${ARGN})            
    SET(larg_names ${arg_names})    
    LIST(FIND larg_names "${arg}" is_arg_name)                   
    IF (is_arg_name GREATER -1)
      SET(${prefix}_${current_arg_name} ${current_arg_list})
      SET(current_arg_name ${arg})
      SET(current_arg_list)
    ELSE (is_arg_name GREATER -1)
      SET(loption_names ${option_names})    
      LIST(FIND loption_names "${arg}" is_option)            
      IF (is_option GREATER -1)
	     SET(${prefix}_${arg} TRUE)
      ELSE (is_option GREATER -1)
	     SET(current_arg_list ${current_arg_list} ${arg})
      ENDIF (is_option GREATER -1)
    ENDIF (is_arg_name GREATER -1)
  ENDFOREACH(arg)
  SET(${prefix}_${current_arg_name} ${current_arg_list})
ENDMACRO(PARSE_ARGUMENTS)
